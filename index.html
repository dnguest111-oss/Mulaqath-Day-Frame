<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mulaqath Day Poster</title>
  <style>
    :root {
      --primary-color: #6366f1;
      --primary-hover: #4f46e5;
      --secondary-color: #f3f4f6;
      --text-color: #1f2937;
      --shadow: 0 10px 25px rgba(0,0,0,0.1);
      --radius: 12px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Anek Malayalam", sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
      margin: 0;
      padding: 20px;
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      background: white;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 30px;
      margin-bottom: 20px;
    }

    h2 {
      font-weight: 700;
      margin-bottom: 30px;
      color: var(--primary-color);
      font-size: 2rem;
    }

    .canvas-container {
      position: relative;
      overflow: hidden;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin: 0 auto 30px;
      background: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 100%;
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
      background: white;
      touch-action: none;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .file-input-wrapper input[type=file] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    .file-input-label {
      display: inline-block;
      padding: 12px 24px;
      background: white;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .file-input-label:hover {
      background: var(--primary-color);
      color: white;
    }

    button {
      padding: 12px 24px;
      border-radius: var(--radius);
      border: none;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .download-btn {
      background: var(--primary-color);
      color: white;
    }

    .download-btn:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3);
    }

    .reset-btn {
      background: #ef4444;
      color: white;
    }

    .reset-btn:hover {
      background: #dc2626;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3);
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      background: white;
      padding: 8px;
      border-radius: var(--radius);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--secondary-color);
      color: var(--text-color);
      border: none;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .zoom-btn:hover {
      background: var(--primary-color);
      color: white;
    }

    .zoom-level {
      min-width: 50px;
      text-align: center;
      font-weight: 600;
    }

    @media (max-width: 768px) {
      .container {
        padding: 20px;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      .controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Anek+Malayalam:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
  <div class="container">
    <h2>ðŸ“¸ Mulaqath Day Poster</h2>

    <div class="canvas-container">
      <canvas id="canvas" width="3508" height="2480"></canvas>
    </div>

    <div class="controls">
      <div class="file-input-wrapper">
        <input type="file" id="photoInput" accept="image/*">
        <label for="photoInput" class="file-input-label">
          <i class="fas fa-upload"></i> Upload Photo
        </label>
      </div>
      
      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut">-</button>
        <span class="zoom-level" id="zoomLevel">100%</span>
        <button class="zoom-btn" id="zoomIn">+</button>
      </div>
      
      <button class="reset-btn" id="resetBtn">
        <i class="fas fa-redo"></i> Reset
      </button>
      
      <button class="download-btn" id="downloadBtn">
        <i class="fas fa-download"></i> Download
      </button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const frame = new Image();
    frame.src = "frame.png";

    let uploadedPhoto = null;
    let offsetX = 0, offsetY = 0;
    let scale = 1;
    let isDragging = false;
    let startX, startY;
    
    // Touch variables for pinch-to-zoom
    let touches = [];
    let initialDistance = 0;
    let initialScale = 1;
    
    // Movement speed factor
    const movementSpeed = 2.5;

    document.getElementById("photoInput").addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        uploadedPhoto = img;
        resetImage();
        draw();
      };
      img.src = URL.createObjectURL(file);
    });

    function resetImage() {
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      updateZoomLevel();
    }

    function updateZoomLevel() {
      document.getElementById("zoomLevel").textContent = Math.round(scale * 100) + '%';
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (uploadedPhoto) {
        const w = uploadedPhoto.width * scale;
        const h = uploadedPhoto.height * scale;
        const x = canvas.width / 2 - w / 2 + offsetX;
        const y = canvas.height / 2 - h / 2 + offsetY;
        ctx.drawImage(uploadedPhoto, x, y, w, h);
      }
      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
    }

    // Mouse events
    canvas.addEventListener("mousedown", e => {
      isDragging = true;
      startX = e.offsetX;
      startY = e.offsetY;
    });
    
    canvas.addEventListener("mouseup", () => isDragging = false);
    canvas.addEventListener("mouseleave", () => isDragging = false);
    
    canvas.addEventListener("mousemove", e => {
      if (isDragging && uploadedPhoto) {
        // Apply movement speed factor
        offsetX += (e.offsetX - startX) * movementSpeed;
        offsetY += (e.offsetY - startY) * movementSpeed;
        startX = e.offsetX;
        startY = e.offsetY;
        draw();
      }
    });

    // Scroll to zoom with center locking
    canvas.addEventListener("wheel", e => {
      if (uploadedPhoto) {
        e.preventDefault();
        
        // Calculate mouse position relative to canvas
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Calculate zoom direction
        const zoomIntensity = 0.1;
        const wheel = e.deltaY < 0 ? 1 : -1;
        const newScale = Math.max(0.1, Math.min(scale + wheel * zoomIntensity, 5));
        
        // Calculate the scaling difference
        const scaleDiff = newScale - scale;
        
        // Adjust offset to zoom towards mouse position
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        
        // Calculate image position
        const imgWidth = uploadedPhoto.width * scale;
        const imgHeight = uploadedPhoto.height * scale;
        const imgX = canvasWidth / 2 - imgWidth / 2 + offsetX;
        const imgY = canvasHeight / 2 - imgHeight / 2 + offsetY;
        
        // Calculate mouse position relative to image
        const relX = mouseX - imgX;
        const relY = mouseY - imgY;
        
        // Calculate new position to keep the point under the mouse
        offsetX -= relX / imgWidth * (uploadedPhoto.width * scaleDiff);
        offsetY -= relY / imgHeight * (uploadedPhoto.height * scaleDiff);
        
        // Apply new scale
        scale = newScale;
        updateZoomLevel();
        draw();
      }
    });

    // Touch events for pinch-to-zoom
    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      touches = Array.from(e.touches);
      
      if (touches.length === 2) {
        // Calculate initial distance for pinch
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        initialDistance = Math.sqrt(dx * dx + dy * dy);
        initialScale = scale;
      } else if (touches.length === 1) {
        // Single touch for dragging
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        startX = touches[0].clientX - rect.left;
        startY = touches[0].clientY - rect.top;
      }
    });

    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      touches = Array.from(e.touches);
      
      if (touches.length === 2 && uploadedPhoto) {
        // Pinch to zoom
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate new scale based on pinch distance
        const newScale = Math.max(0.1, Math.min(initialScale * (distance / initialDistance), 5));
        
        // Calculate center point between the two touches
        const centerX = (touches[0].clientX + touches[1].clientX) / 2;
        const centerY = (touches[0].clientY + touches[1].clientY) / 2;
        
        const rect = canvas.getBoundingClientRect();
        const canvasX = centerX - rect.left;
        const canvasY = centerY - rect.top;
        
        // Calculate the scaling difference
        const scaleDiff = newScale - scale;
        
        // Calculate image position
        const imgWidth = uploadedPhoto.width * scale;
        const imgHeight = uploadedPhoto.height * scale;
        const imgX = canvas.width / 2 - imgWidth / 2 + offsetX;
        const imgY = canvas.height / 2 - imgHeight / 2 + offsetY;
        
        // Calculate center position relative to image
        const relX = canvasX - imgX;
        const relY = canvasY - imgY;
        
        // Calculate new position to keep the point under the center
        offsetX -= relX / imgWidth * (uploadedPhoto.width * scaleDiff);
        offsetY -= relY / imgHeight * (uploadedPhoto.height * scaleDiff);
        
        // Apply new scale
        scale = newScale;
        updateZoomLevel();
        draw();
      } else if (touches.length === 1 && isDragging && uploadedPhoto) {
        // Single touch drag - apply movement speed factor
        const rect = canvas.getBoundingClientRect();
        const currentX = touches[0].clientX - rect.left;
        const currentY = touches[0].clientY - rect.top;
        
        offsetX += (currentX - startX) * movementSpeed;
        offsetY += (currentY - startY) * movementSpeed;
        
        startX = currentX;
        startY = currentY;
        draw();
      }
    });

    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      touches = Array.from(e.touches);
      
      if (touches.length < 2) {
        initialDistance = 0;
      }
      
      if (touches.length === 0) {
        isDragging = false;
      }
    });

    // Zoom buttons
    document.getElementById("zoomIn").addEventListener("click", () => {
      if (uploadedPhoto) {
        scale = Math.min(scale + 0.1, 5);
        updateZoomLevel();
        draw();
      }
    });

    document.getElementById("zoomOut").addEventListener("click", () => {
      if (uploadedPhoto) {
        scale = Math.max(scale - 0.1, 0.1);
        updateZoomLevel();
        draw();
      }
    });

    // Reset button
    document.getElementById("resetBtn").addEventListener("click", () => {
      if (uploadedPhoto) {
        resetImage();
        draw();
      }
    });

    // Download button with serial number
    document.getElementById("downloadBtn").addEventListener("click", () => {
      // Get or initialize serial number from localStorage
      let serialNumber = parseInt(localStorage.getItem('mulaqathSerial') || '0');
      serialNumber++;
      localStorage.setItem('mulaqathSerial', serialNumber);
      
      // Format serial number with leading zeros (e.g., 001, 002, etc.)
      const formattedSerial = serialNumber.toString().padStart(3, '0');
      
      const link = document.createElement("a");
      link.download = `mulaqath_${formattedSerial}.png`;
      
      // Create a temporary canvas at full resolution
      const tempCanvas = document.createElement("canvas");
      const tempCtx = tempCanvas.getContext("2d");
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      
      // Draw the current state to the temporary canvas
      tempCtx.drawImage(canvas, 0, 0);
      
      // Convert to high-quality PNG
      link.href = tempCanvas.toDataURL("image/png", 1.0);
      link.click();
    });

    frame.onload = draw;
  </script>
</body>
</html>
